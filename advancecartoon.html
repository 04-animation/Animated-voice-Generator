<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Cartoon Voice Dubbing Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .upload-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 2px dashed #667eea;
            border-radius: 15px;
            background: rgba(102, 126, 234, 0.1);
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.2);
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .record-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .record-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 107, 107, 0.3);
        }

        .record-btn.recording {
            background: linear-gradient(45deg, #ff4757, #ff3838);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .voice-analysis {
            background: rgba(78, 205, 196, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            display: none;
        }

        .voice-analysis.show {
            display: block;
        }

        .voice-analysis h3 {
            color: #333;
            margin-bottom: 15px;
        }

        .voice-characteristics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .characteristic {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #4ecdc4;
        }

        .characteristic-label {
            font-weight: bold;
            color: #333;
            font-size: 12px;
        }

        .characteristic-value {
            font-size: 18px;
            color: #4ecdc4;
            font-weight: bold;
        }

        .voice-type {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .voice-btn {
            padding: 15px 20px;
            border: 2px solid #667eea;
            background: transparent;
            color: #667eea;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .voice-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .voice-btn:hover::before {
            left: 100%;
        }

        .voice-btn.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .voice-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .advanced-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: bold;
            color: #333;
            font-size: 14px;
        }

        .slider {
            width: 160px;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            position: relative;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
        }

        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            cursor: pointer;
            border: none;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
        }

        .slider-value {
            background: rgba(102, 126, 234, 0.2);
            color: #333;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            min-width: 50px;
        }

        .audio-player {
            margin: 20px 0;
            padding: 20px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            display: none;
        }

        .audio-player.show {
            display: block;
        }

        .audio-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .play-btn, .download-btn, .compare-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .play-btn:hover, .download-btn:hover, .compare-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }

        .compare-btn {
            background: linear-gradient(45deg, #ffa726, #ff9800);
        }

        .compare-btn:hover {
            box-shadow: 0 5px 15px rgba(255, 167, 38, 0.3);
        }

        .waveform {
            width: 100%;
            height: 80px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .wave-bar {
            width: 4px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            margin: 0 1px;
            border-radius: 2px;
            animation: wave 1s ease-in-out infinite;
            transform-origin: center;
        }

        @keyframes wave {
            0%, 100% { transform: scaleY(0.5); }
            50% { transform: scaleY(1); }
        }

        .comparison-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            display: none;
        }

        .comparison-section.show {
            display: grid;
        }

        .comparison-audio {
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4ecdc4;
        }

        .status {
            margin: 15px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
            display: none;
        }

        .status.success {
            background: rgba(78, 205, 196, 0.2);
            color: #2d8075;
            display: block;
        }

        .status.error {
            background: rgba(255, 107, 107, 0.2);
            color: #d63031;
            display: block;
        }

        .processing {
            background: rgba(255, 193, 7, 0.2);
            color: #f39c12;
            display: block;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .preset-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .preset-btn {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
            color: #333;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 154, 158, 0.3);
        }

        .voice-morphing {
            background: rgba(255, 193, 7, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .voice-morphing h3 {
            color: #333;
            margin-bottom: 15px;
        }

        .morph-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .advanced-controls {
                grid-template-columns: 1fr;
            }
            
            .voice-type {
                grid-template-columns: 1fr;
            }
            
            .comparison-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎭 Advanced Cartoon Voice Dubbing</h1>
        
        <div class="upload-section">
            <p style="margin-bottom: 15px; color: #666;">Upload audio file or record your voice for intelligent processing</p>
            <input type="file" id="audioFile" class="file-input" accept="audio/*">
            <button class="upload-btn" onclick="document.getElementById('audioFile').click()">
                📁 Upload Audio
            </button>
            <button class="record-btn" id="recordBtn" onclick="toggleRecording()">
                🎤 Record Voice
            </button>
        </div>

        <div class="voice-analysis" id="voiceAnalysis">
            <h3>🔍 Voice Analysis</h3>
            <div class="voice-characteristics" id="voiceCharacteristics"></div>
        </div>

        <div class="voice-type">
            <button class="voice-btn active" data-voice="smart-cartoon">🧠 Smart Cartoon</button>
            <button class="voice-btn" data-voice="adaptive-chipmunk">🐿️ Adaptive Chipmunk</button>
            <button class="voice-btn" data-voice="dynamic-robot">🤖 Dynamic Robot</button>
            <button class="voice-btn" data-voice="character-deep">👹 Character Deep</button>
            <button class="voice-btn" data-voice="bubble-helium">🎈 Bubble Helium</button>
            <button class="voice-btn" data-voice="custom-morph">✨ Custom Morph</button>
        </div>

        <div class="voice-morphing">
            <h3>🎚️ Voice Morphing Controls</h3>
            <div class="preset-buttons">
                <button class="preset-btn" onclick="applyPreset('preserve-tone')">Preserve Tone</button>
                <button class="preset-btn" onclick="applyPreset('enhance-character')">Enhance Character</button>
                <button class="preset-btn" onclick="applyPreset('extreme-cartoon')">Extreme Cartoon</button>
                <button class="preset-btn" onclick="applyPreset('natural-blend')">Natural Blend</button>
            </div>
            <div class="morph-controls">
                <div class="control-group">
                    <label>Voice Formant</label>
                    <input type="range" class="slider" id="formantSlider" min="0.3" max="3" step="0.1" value="1.5">
                    <span class="slider-value" id="formantValue">1.5</span>
                </div>
                <div class="control-group">
                    <label>Timbre Shift</label>
                    <input type="range" class="slider" id="timbreSlider" min="0.2" max="2.8" step="0.1" value="1.2">
                    <span class="slider-value" id="timbreValue">1.2</span>
                </div>
                <div class="control-group">
                    <label>Resonance</label>
                    <input type="range" class="slider" id="resonanceSlider" min="0.1" max="2" step="0.1" value="0.8">
                    <span class="slider-value" id="resonanceValue">0.8</span>
                </div>
            </div>
        </div>

        <div class="advanced-controls">
            <div class="control-group">
                <label>Pitch Adaptation</label>
                <input type="range" class="slider" id="pitchSlider" min="0.5" max="2.5" step="0.1" value="1.5">
                <span class="slider-value" id="pitchValue">1.5</span>
            </div>
            <div class="control-group">
                <label>Speed Morphing</label>
                <input type="range" class="slider" id="speedSlider" min="0.5" max="2.2" step="0.1" value="1.1">
                <span class="slider-value" id="speedValue">1.1</span>
            </div>
            <div class="control-group">
                <label>Character Echo</label>
                <input type="range" class="slider" id="echoSlider" min="0" max="1" step="0.1" value="0.25">
                <span class="slider-value" id="echoValue">0.25</span>
            </div>
            <div class="control-group">
                <label>Vocal Fry</label>
                <input type="range" class="slider" id="frySlider" min="0" max="1" step="0.1" value="0.3">
                <span class="slider-value" id="fryValue">0.3</span>
            </div>
            <div class="control-group">
                <label>Breathiness</label>
                <input type="range" class="slider" id="breathSlider" min="0" max="1" step="0.1" value="0.2">
                <span class="slider-value" id="breathValue">0.2</span>
            </div>
            <div class="control-group">
                <label>Vibrato</label>
                <input type="range" class="slider" id="vibratoSlider" min="0" max="1" step="0.1" value="0.15">
                <span class="slider-value" id="vibratoValue">0.15</span>
            </div>
        </div>

        <div class="status" id="status"></div>

        <div class="comparison-section" id="comparisonSection">
            <div class="comparison-audio">
                <h4>🎤 Original Voice</h4>
                <div class="waveform" id="originalWaveform"></div>
                <button class="play-btn" id="playOriginal" onclick="playOriginal()">▶️ Play Original</button>
            </div>
            <div class="comparison-audio">
                <h4>🎭 Cartoon Voice</h4>
                <div class="waveform" id="cartoonWaveform"></div>
                <button class="play-btn" id="playCartoon" onclick="playCartoon()">▶️ Play Cartoon</button>
            </div>
        </div>

        <div class="audio-player" id="audioPlayer">
            <h3>🎵 Processed Audio</h3>
            <div class="waveform" id="waveform"></div>
            <div class="audio-controls">
                <button class="play-btn" id="playBtn" onclick="togglePlay()">▶️ Play</button>
                <button class="compare-btn" id="compareBtn" onclick="toggleComparison()">🔄 Compare</button>
                <button class="download-btn" id="downloadBtn" onclick="downloadAudio()">💾 Download</button>
            </div>
        </div>
    </div>

    <script>
        let audioContext;
        let sourceNode;
        let originalBuffer;
        let processedBuffer;
        let isRecording = false;
        let mediaRecorder;
        let recordedChunks = [];
        let currentVoiceType = 'smart-cartoon';
        let isPlaying = false;
        let voiceCharacteristics = {};
        let originalSourceNode;
        let cartoonSourceNode;

        // Initialize Web Audio API
        function initAudioContext() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Voice analysis function
        function analyzeVoice(buffer) {
            const audioData = buffer.getChannelData(0);
            const sampleRate = buffer.sampleRate;
            
            // Calculate fundamental frequency (pitch)
            const pitch = calculatePitch(audioData, sampleRate);
            
            // Calculate formant frequencies
            const formants = calculateFormants(audioData, sampleRate);
            
            // Calculate spectral characteristics
            const spectral = calculateSpectralFeatures(audioData, sampleRate);
            
            // Calculate temporal features
            const temporal = calculateTemporalFeatures(audioData, sampleRate);
            
            voiceCharacteristics = {
                pitch: pitch,
                formant1: formants.f1,
                formant2: formants.f2,
                brightness: spectral.brightness,
                roughness: spectral.roughness,
                energy: temporal.energy,
                tempo: temporal.tempo
            };
            
            displayVoiceAnalysis();
            adaptControlsToVoice();
        }

        // Calculate pitch using autocorrelation
        function calculatePitch(audioData, sampleRate) {
            const bufferSize = 2048;
            const threshold = 0.2;
            let pitch = 0;
            let pitchCount = 0;
            
            for (let i = 0; i < audioData.length - bufferSize; i += bufferSize) {
                const slice = audioData.slice(i, i + bufferSize);
                const autocorr = autocorrelation(slice);
                
                let maxVal = 0;
                let maxIndex = 0;
                
                for (let j = 1; j < autocorr.length / 2; j++) {
                    if (autocorr[j] > maxVal && autocorr[j] > threshold) {
                        maxVal = autocorr[j];
                        maxIndex = j;
                    }
                }
                
                if (maxIndex > 0) {
                    pitch += sampleRate / maxIndex;
                    pitchCount++;
                }
            }
            
            return pitchCount > 0 ? pitch / pitchCount : 150;
        }

        // Autocorrelation function
        function autocorrelation(buffer) {
            const result = new Float32Array(buffer.length);
            for (let i = 0; i < buffer.length; i++) {
                let sum = 0;
                for (let j = 0; j < buffer.length - i; j++) {
                    sum += buffer[j] * buffer[j + i];
                }
                result[i] = sum;
            }
            return result;
        }

        // Calculate formant frequencies
        function calculateFormants(audioData, sampleRate) {
            // Simplified formant estimation using LPC
            const windowSize = 1024;
            const overlap = 512;
            let f1Sum = 0, f2Sum = 0;
            let count = 0;
            
            for (let i = 0; i < audioData.length - windowSize; i += overlap) {
                const window = audioData.slice(i, i + windowSize);
                const spectrum = getSpectrum(window);
                const peaks = findSpectralPeaks(spectrum, sampleRate);
                
                if (peaks.length >= 2) {
                    f1Sum += peaks[0];
                    f2Sum += peaks[1];
                    count++;
                }
            }
            
            return {
                f1: count > 0 ? f1Sum / count : 800,
                f2: count > 0 ? f2Sum / count : 1200
            };
        }

        // Get frequency spectrum
        function getSpectrum(audioData) {
            const fftSize = 1024;
            const fft = new Float32Array(fftSize);
            for (let i = 0; i < Math.min(audioData.length, fftSize); i++) {
                fft[i] = audioData[i];
            }
            
            // Simple magnitude spectrum calculation
            const spectrum = new Float32Array(fftSize / 2);
            for (let i = 0; i < spectrum.length; i++) {
                const real = fft[i * 2] || 0;
                const imag = fft[i * 2 + 1] || 0;
                spectrum[i] = Math.sqrt(real * real + imag * imag);
            }
            
            return spectrum;
        }

        // Find spectral peaks
        function findSpectralPeaks(spectrum, sampleRate) {
            const peaks = [];
            const minPeakDistance = 50; // Hz
            const binSize = sampleRate / (spectrum.length * 2);
            
            for (let i = 1; i < spectrum.length - 1; i++) {
                if (spectrum[i] > spectrum[i - 1] && spectrum[i] > spectrum[i + 1]) {
                    const frequency = i * binSize;
                    if (frequency > 200 && frequency < 3000) {
                        peaks.push(frequency);
                    }
                }
            }
            
            return peaks.sort((a, b) => a - b).slice(0, 3);
        }

        // Calculate spectral features
        function calculateSpectralFeatures(audioData, sampleRate) {
            const spectrum = getSpectrum(audioData);
            let brightness = 0;
            let roughness = 0;
            
            // Brightness (high frequency content)
            for (let i = spectrum.length / 2; i < spectrum.length; i++) {
                brightness += spectrum[i];
            }
            brightness /= spectrum.length / 2;
            
            // Roughness (spectral irregularity)
            for (let i = 1; i < spectrum.length - 1; i++) {
                roughness += Math.abs(spectrum[i] - (spectrum[i - 1] + spectrum[i + 1]) / 2);
            }
            roughness /= spectrum.length - 2;
            
            return { brightness, roughness };
        }

        // Calculate temporal features
        function calculateTemporalFeatures(audioData, sampleRate) {
            let energy = 0;
            let zeroCrossings = 0;
            
            for (let i = 0; i < audioData.length; i++) {
                energy += audioData[i] * audioData[i];
                if (i > 0 && ((audioData[i] > 0) !== (audioData[i - 1] > 0))) {
                    zeroCrossings++;
                }
            }
            
            energy /= audioData.length;
            const tempo = zeroCrossings / (audioData.length / sampleRate);
            
            return { energy, tempo };
        }

        // Display voice analysis
        function displayVoiceAnalysis() {
            const container = document.getElementById('voiceCharacteristics');
            container.innerHTML = '';
            
            const characteristics = [
                { label: 'Pitch', value: Math.round(voiceCharacteristics.pitch) + ' Hz', color: '#667eea' },
                { label: 'Formant 1', value: Math.round(voiceCharacteristics.formant1) + ' Hz', color: '#764ba2' },
                { label: 'Formant 2', value: Math.round(voiceCharacteristics.formant2) + ' Hz', color: '#4ecdc4' },
                { label: 'Brightness', value: (voiceCharacteristics.brightness * 100).toFixed(1) + '%', color: '#ffa726' },
                { label: 'Energy', value: (voiceCharacteristics.energy * 100).toFixed(1) + '%', color: '#ff6b6b' },
                { label: 'Tempo', value: voiceCharacteristics.tempo.toFixed(1) + ' Hz', color: '#9c27b0' }
            ];
            
            characteristics.forEach(char => {
                const div = document.createElement('div');
                div.className = 'characteristic';
                div.innerHTML = `
                    <div class="characteristic-label">${char.label}</div>
                    <div class="characteristic-value" style="color: ${char.color}">${char.value}</div>
                `;
                container.appendChild(div);
            });
            
            document.getElementById('voiceAnalysis').classList.add('show');
        }

        // Adapt controls to voice characteristics
        function adaptControlsToVoice() {
            const pitch = voiceCharacteristics.pitch;
            const formant1 = voiceCharacteristics.formant1;
            const brightness = voiceCharacteristics.brightness;
            
            // Adapt pitch slider based on original pitch
            if (pitch < 120) {
                document.getElementById('pitchSlider').value = 1.8; // Higher pitch for low voices
            } else if (pitch > 250) {
                document.getElementById('pitchSlider').value = 1.2; // Lower pitch for high voices
            } else {
                document.getElementById('pitchSlider').value = 1.5; // Medium pitch
            }
            
            // Adapt formant based on voice characteristics
            if (formant1 < 600) {
                document.getElementById('formantSlider').value = 2.0; // Increase formant for deep voices
            } else if (formant1 > 1000) {
                document.getElementById('formantSlider').value = 1.0; // Decrease formant for bright voices
            } else {
                document.getElementById('formantSlider').value = 1.5; // Medium formant
            }
            
            // Adapt other controls based on voice brightness
            if (brightness > 0.5) {
                document.getElementById('timbreSlider').value = 0.8; // Reduce timbre for bright voices
                document.getElementById('breathSlider').value = 0.4; // Add breathiness
            } else {
                document.getElementById('timbreSlider').value = 1.5; // Increase timbre for dark voices
                document.getElementById('breathSlider').value = 0.1; // Less breathiness
            }
            
            updateAllSliderValues();
            if (originalBuffer) {
                processAudioWithIntelligence();
            }
        }

        // Voice type buttons
        document.querySelectorAll('.voice-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.voice-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentVoiceType = this.dataset.voice;
                setIntelligentVoicePreset(currentVoiceType);
                if (originalBuffer) {
                    processAudioWithIntelligence();
                }
            });
        });

        // Intelligent voice presets
        function setIntelligentVoicePreset(type) {
            const pitch = voiceCharacteristics.pitch || 150;
            const formant1 = voiceCharacteristics.formant1 || 800;
            const brightness = voiceCharacteristics.brightness || 0.3;
            
            switch(type) {
                case 'smart-cartoon':
                    adaptiveCartoonPreset(pitch, formant1, brightness);
                    break;
                case 'adaptive-chipmunk':
                    adaptiveChipmunkPreset(pitch, formant1, brightness);
                    break;
                case 'dynamic-robot':
                    dynamicRobotPreset(pitch, formant1, brightness);
                    break;
                case 'character-deep':
                    characterDeepPreset(pitch, formant1, brightness);
                    break;
                case 'bubble-helium':
                    bubbleHeliumPreset(pitch, formant1, brightness);
                    break;
                case 'custom-morph':
                    customMorphPreset(pitch, formant1, brightness);
                    break;
            }
            updateAllSliderValues();
        }

        // Adaptive cartoon preset
        function adaptiveCartoonPreset(pitch, formant1, brightness) {
            const pitchFactor = pitch < 150 ? 1.8 : (pitch > 250 ? 1.3 : 1.5);
            const formantFactor = formant1 < 700 ? 2.2 : (formant1 > 1000 ? 1.2 : 1.6);
            
            document.getElementById('pitchSlider').value = pitchFactor;
            document.getElementById('formantSlider').value = formantFactor;
            document.getElementById('timbreSlider').value = brightness > 0.5 ? 1.0 : 1.4;
            document.getElementById('speedSlider').value = 1.2;
            document.getElementById('resonanceSlider').value = 0.9;
            document.getElementById('echoSlider').value = 0.25;
            document.getElementById('frySlider').value = 0.2;
            document.getElementById('breathSlider').value = 0.3;
            document.getElementById('vibratoSlider').value = 0.2;
        }

        // Adaptive chipmunk preset
        function adaptiveChipmunkPreset(pitch, formant1, brightness) {
            const pitchFactor = pitch < 150 ? 2.2 : (pitch > 250 ? 1.6 : 1.9);
            const speedFactor = pitch < 150 ? 1.6 : (pitch > 250 ? 1.3 : 1.5);
            
            document.getElementById('pitchSlider').value = pitchFactor;
            document.getElementById('formantSlider').value = 2.5;
            document.getElementById('timbreSlider').value = 1.8;
            document.getElementById('speedSlider').value = speedFactor;
            document.getElementById('resonanceSlider').value = 1.2;
            document.getElementById('echoSlider').value = 0.1;
            document.getElementById('frySlider').value = 0.1;
            document.getElementById('breathSlider').value = 0.2;
            document.getElementById('vibratoSlider').value = 0.3;
        }

        // Dynamic robot preset
        function dynamicRobotPreset(pitch, formant1, brightness) {
            const pitchFactor = pitch > 200 ? 0.7 : (pitch < 120 ? 0.9 : 0.8);
            
            document.getElementById('pitchSlider').value = pitchFactor;
            document.getElementById('formantSlider').value = 0.6;
            document.getElementById('timbreSlider').value = 0.4;
            document.getElementById('speedSlider').value = 0.9;
            document.getElementById('resonanceSlider').value = 1.8;
            document.getElementById('echoSlider').value = 0.6;
            document.getElementById('frySlider').value = 0.8;
            document.getElementById('breathSlider').value = 0.1;
            document.getElementById('vibratoSlider').value = 0.1;
        }

        // Character deep preset
        function characterDeepPreset(pitch, formant1, brightness) {
            const pitchFactor = pitch > 180 ? 0.5 : (pitch < 100 ? 0.7 : 0.6);
            
            document.getElementById('pitchSlider').value = pitchFactor;
            document.getElementById('formantSlider').value = 0.4;
            document.getElementById('timbreSlider').value = 0.6;
            document.getElementById('speedSlider').value = 0.8;
            document.getElementById('resonanceSlider').value = 1.5;
            document.getElementById('echoSlider').value = 0.4;
            document.getElementById('frySlider').value = 0.6;
            document.getElementById('breathSlider').value = 0.3;
            document.getElementById('vibratoSlider').value = 0.2;
        }

        // Bubble helium preset
        function bubbleHeliumPreset(pitch, formant1, brightness) {
            const pitchFactor = pitch < 150 ? 2.0 : (pitch > 250 ? 1.5 : 1.8);
            
            document.getElementById('pitchSlider').value = pitchFactor;
            document.getElementById('formantSlider').value = 2.8;
            document.getElementById('timbreSlider').value = 2.2;
            document.getElementById('speedSlider').value = 1.3;
            document.getElementById('resonanceSlider').value = 0.6;
            document.getElementById('echoSlider').value = 0.2;
            document.getElementById('frySlider').value = 0.1;
            document.getElementById('breathSlider').value = 0.4;
            document.getElementById('vibratoSlider').value = 0.4;
        }

        // Custom morph preset
        function customMorphPreset(pitch, formant1, brightness) {
            // Balanced preset that preserves some original characteristics
            document.getElementById('pitchSlider').value = 1.3;
            document.getElementById('formantSlider').value = 1.4;
            document.getElementById('timbreSlider').value = 1.2;
            document.getElementById('speedSlider').value = 1.1;
            document.getElementById('resonanceSlider').value = 1.0;
            document.getElementById('echoSlider').value = 0.3;
            document.getElementById('frySlider').value = 0.3;
            document.getElementById('breathSlider').value = 0.2;
            document.getElementById('vibratoSlider').value = 0.15;
        }

        // Preset application
        function applyPreset(presetType) {
            const pitch = voiceCharacteristics.pitch || 150;
            const formant1 = voiceCharacteristics.formant1 || 800;
            const brightness = voiceCharacteristics.brightness || 0.3;
            
            switch(presetType) {
                case 'preserve-tone':
                    document.getElementById('pitchSlider').value = pitch > 200 ? 1.2 : (pitch < 120 ? 1.4 : 1.3);
                    document.getElementById('formantSlider').value = 1.1;
                    document.getElementById('timbreSlider').value = 1.0;
                    break;
                case 'enhance-character':
                    document.getElementById('pitchSlider').value = 1.6;
                    document.getElementById('formantSlider').value = 1.8;
                    document.getElementById('timbreSlider').value = 1.5;
                    break;
                case 'extreme-cartoon':
                    document.getElementById('pitchSlider').value = 2.0;
                    document.getElementById('formantSlider').value = 2.5;
                    document.getElementById('timbreSlider').value = 2.0;
                    break;
                case 'natural-blend':
                    document.getElementById('pitchSlider').value = 1.2;
                    document.getElementById('formantSlider').value = 1.3;
                    document.getElementById('timbreSlider').value = 1.1;
                    break;
            }
            updateAllSliderValues();
            if (originalBuffer) {
                processAudioWithIntelligence();
            }
        }

        // Update all slider values
        function updateAllSliderValues() {
            const sliders = ['pitch', 'speed', 'echo', 'formant', 'timbre', 'resonance', 'fry', 'breath', 'vibrato'];
            sliders.forEach(slider => {
                const element = document.getElementById(slider + 'Slider');
                const valueElement = document.getElementById(slider + 'Value');
                if (element && valueElement) {
                    valueElement.textContent = element.value;
                }
            });
        }

        // Add event listeners to all sliders
        function addSliderListeners() {
            const sliders = ['pitch', 'speed', 'echo', 'formant', 'timbre', 'resonance', 'fry', 'breath', 'vibrato'];
            sliders.forEach(slider => {
                const element = document.getElementById(slider + 'Slider');
                if (element) {
                    element.addEventListener('input', function() {
                        updateAllSliderValues();
                        if (originalBuffer) processAudioWithIntelligence();
                    });
                }
            });
        }

        // File upload handler
        document.getElementById('audioFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                showStatus('Analyzing audio file...', 'processing');
                const reader = new FileReader();
                reader.onload = function(event) {
                    if (!audioContext) initAudioContext();
                    audioContext.decodeAudioData(event.target.result)
                        .then(buffer => {
                            originalBuffer = buffer;
                            analyzeVoice(buffer);
                            processAudioWithIntelligence();
                        })
                        .catch(error => {
                            showStatus('Error processing audio file', 'error');
                        });
                };
                reader.readAsArrayBuffer(file);
            }
        });

        // Recording functionality
        async function toggleRecording() {
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    recordedChunks = [];

                    mediaRecorder.ondataavailable = function(e) {
                        if (e.data.size > 0) {
                            recordedChunks.push(e.data);
                        }
                    };

                    mediaRecorder.onstop = function() {
                        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            if (!audioContext) initAudioContext();
                            audioContext.decodeAudioData(event.target.result)
                                .then(buffer => {
                                    originalBuffer = buffer;
                                    analyzeVoice(buffer);
                                    processAudioWithIntelligence();
                                })
                                .catch(error => {
                                    showStatus('Error processing recorded audio', 'error');
                                });
                        };
                        reader.readAsArrayBuffer(blob);
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    document.getElementById('recordBtn').textContent = '⏹️ Stop Recording';
                    document.getElementById('recordBtn').classList.add('recording');
                    showStatus('Recording... Click stop when done', 'processing');
                } catch (error) {
                    showStatus('Error accessing microphone', 'error');
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('recordBtn').textContent = '🎤 Record Voice';
                document.getElementById('recordBtn').classList.remove('recording');
                showStatus('Analyzing recorded voice...', 'processing');
            }
        }

        // Advanced audio processing with intelligence
        async function processAudioWithIntelligence() {
            if (!originalBuffer || !audioContext) return;

            showStatus('Applying intelligent voice morphing...', 'processing');

            try {
                const pitch = parseFloat(document.getElementById('pitchSlider').value);
                const speed = parseFloat(document.getElementById('speedSlider').value);
                const echo = parseFloat(document.getElementById('echoSlider').value);
                const formant = parseFloat(document.getElementById('formantSlider').value);
                const timbre = parseFloat(document.getElementById('timbreSlider').value);
                const resonance = parseFloat(document.getElementById('resonanceSlider').value);
                const fry = parseFloat(document.getElementById('frySlider').value);
                const breath = parseFloat(document.getElementById('breathSlider').value);
                const vibrato = parseFloat(document.getElementById('vibratoSlider').value);

                const sampleRate = audioContext.sampleRate;
                const channels = originalBuffer.numberOfChannels;
                const length = Math.floor(originalBuffer.length / speed);
                processedBuffer = audioContext.createBuffer(channels, length, sampleRate);

                // Process each channel with advanced effects
                for (let channel = 0; channel < channels; channel++) {
                    const inputData = originalBuffer.getChannelData(channel);
                    const outputData = processedBuffer.getChannelData(channel);

                    // Apply speed change with pitch preservation
                    for (let i = 0; i < length; i++) {
                        const sourceIndex = Math.floor(i * speed);
                        if (sourceIndex < inputData.length) {
                            outputData[i] = inputData[sourceIndex];
                        }
                    }

                    // Apply formant shifting (simplified)
                    applyFormantShift(outputData, formant, sampleRate);

                    // Apply timbre modification
                    applyTimbreShift(outputData, timbre, sampleRate);

                    // Apply pitch shifting with voice characteristics preservation
                    applyIntelligentPitchShift(outputData, pitch, voiceCharacteristics);

                    // Apply resonance
                    applyResonance(outputData, resonance, sampleRate);

                    // Apply vocal fry
                    applyVocalFry(outputData, fry, sampleRate);

                    // Apply breathiness
                    applyBreathiness(outputData, breath, sampleRate);

                    // Apply vibrato
                    applyVibrato(outputData, vibrato, sampleRate);

                    // Apply echo with character preservation
                    applyCharacterEcho(outputData, echo, sampleRate);
                }

                showStatus('Advanced cartoon voice applied successfully!', 'success');
                showAudioPlayer();
                generateAdvancedWaveform();
                
            } catch (error) {
                showStatus('Error processing audio', 'error');
                console.error('Processing error:', error);
            }
        }

        // Apply formant shifting
        function applyFormantShift(data, formant, sampleRate) {
            const windowSize = 1024;
            const hopSize = 512;
            
            for (let i = 0; i < data.length - windowSize; i += hopSize) {
                const window = data.slice(i, i + windowSize);
                
                // Apply formant shift using spectral envelope modification
                for (let j = 0; j < window.length; j++) {
                    const freq = j * sampleRate / windowSize;
                    const formantEffect = 1 + (formant - 1) * Math.exp(-Math.pow(freq - 1000, 2) / 200000);
                    window[j] *= formantEffect;
                }
                
                // Copy back to output
                for (let j = 0; j < window.length && i + j < data.length; j++) {
                    data[i + j] = window[j];
                }
            }
        }

        // Apply timbre shifting
        function applyTimbreShift(data, timbre, sampleRate) {
            const brightness = timbre > 1 ? (timbre - 1) * 0.3 : 0;
            const darkness = timbre < 1 ? (1 - timbre) * 0.3 : 0;
            
            for (let i = 1; i < data.length; i++) {
                const highFreq = data[i] - data[i - 1];
                data[i] += highFreq * brightness - highFreq * darkness;
            }
        }

        // Apply intelligent pitch shifting
        function applyIntelligentPitchShift(data, pitch, voiceChar) {
            const originalPitch = voiceChar.pitch || 150;
            const adaptivePitch = pitch * (1 + (originalPitch - 150) / 300);
            
            for (let i = 0; i < data.length; i++) {
                data[i] *= adaptivePitch > 1.0 ? Math.min(1.5, adaptivePitch) : Math.max(0.5, adaptivePitch);
            }
        }

        // Apply resonance
        function applyResonance(data, resonance, sampleRate) {
            const delay = Math.floor(sampleRate * 0.01); // 10ms delay
            
            for (let i = delay; i < data.length; i++) {
                data[i] += data[i - delay] * resonance * 0.3;
            }
        }

        // Apply vocal fry
        function applyVocalFry(data, fry, sampleRate) {
            const fryFreq = 70; // Hz
            const fryPeriod = sampleRate / fryFreq;
            
            for (let i = 0; i < data.length; i++) {
                const fryMod = Math.sin(2 * Math.PI * i / fryPeriod) * fry * 0.2;
                data[i] *= (1 + fryMod);
            }
        }

        // Apply breathiness
        function applyBreathiness(data, breath, sampleRate) {
            for (let i = 0; i < data.length; i++) {
                const noise = (Math.random() - 0.5) * breath * 0.1;
                data[i] += noise;
            }
        }

        // Apply vibrato
        function applyVibrato(data, vibrato, sampleRate) {
            const vibratoFreq = 5; // Hz
            const vibratoDepth = vibrato * 0.02;
            
            for (let i = 0; i < data.length; i++) {
                const vibratoMod = Math.sin(2 * Math.PI * i * vibratoFreq / sampleRate) * vibratoDepth;
                data[i] *= (1 + vibratoMod);
            }
        }

        // Apply character echo
        function applyCharacterEcho(data, echo, sampleRate) {
            const delayTime = 0.12; // 120ms delay
            const delaySamples = Math.floor(delayTime * sampleRate);
            
            for (let i = delaySamples; i < data.length; i++) {
                data[i] += data[i - delaySamples] * echo * 0.6;
            }
        }

        // Show status message
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            
            if (type === 'processing') {
                status.innerHTML = `<div class="spinner"></div>${message}`;
            }
        }

        // Show audio player
        function showAudioPlayer() {
            document.getElementById('audioPlayer').classList.add('show');
        }

        // Generate advanced waveform visualization
        function generateAdvancedWaveform() {
            const waveform = document.getElementById('waveform');
            waveform.innerHTML = '';
            
            if (processedBuffer) {
                const data = processedBuffer.getChannelData(0);
                const step = Math.floor(data.length / 80);
                
                for (let i = 0; i < 80; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'wave-bar';
                    
                    let sum = 0;
                    for (let j = 0; j < step; j++) {
                        if (i * step + j < data.length) {
                            sum += Math.abs(data[i * step + j]);
                        }
                    }
                    const average = sum / step;
                    
                    bar.style.height = `${Math.max(5, average * 300)}px`;
                    bar.style.animationDelay = `${i * 0.03}s`;
                    waveform.appendChild(bar);
                }
            }
        }

        // Toggle comparison
        function toggleComparison() {
            const comparisonSection = document.getElementById('comparisonSection');
            comparisonSection.classList.toggle('show');
            
            if (comparisonSection.classList.contains('show')) {
                generateComparisonWaveforms();
            }
        }

        // Generate comparison waveforms
        function generateComparisonWaveforms() {
            generateWaveformForElement('originalWaveform', originalBuffer);
            generateWaveformForElement('cartoonWaveform', processedBuffer);
        }

        // Generate waveform for specific element
        function generateWaveformForElement(elementId, buffer) {
            const waveform = document.getElementById(elementId);
            waveform.innerHTML = '';
            
            if (buffer) {
                const data = buffer.getChannelData(0);
                const step = Math.floor(data.length / 60);
                
                for (let i = 0; i < 60; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'wave-bar';
                    
                    let sum = 0;
                    for (let j = 0; j < step; j++) {
                        if (i * step + j < data.length) {
                            sum += Math.abs(data[i * step + j]);
                        }
                    }
                    const average = sum / step;
                    
                    bar.style.height = `${Math.max(3, average * 200)}px`;
                    bar.style.animationDelay = `${i * 0.05}s`;
                    waveform.appendChild(bar);
                }
            }
        }

        // Play processed audio
        function togglePlay() {
            if (!processedBuffer) return;

            if (!isPlaying) {
                if (sourceNode) {
                    sourceNode.stop();
                }
                
                sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = processedBuffer;
                sourceNode.connect(audioContext.destination);
                sourceNode.start();
                
                sourceNode.onended = function() {
                    isPlaying = false;
                    document.getElementById('playBtn').textContent = '▶️ Play';
                };
                
                isPlaying = true;
                document.getElementById('playBtn').textContent = '⏸️ Stop';
            } else {
                if (sourceNode) {
                    sourceNode.stop();
                }
                isPlaying = false;
                document.getElementById('playBtn').textContent = '▶️ Play';
            }
        }

        // Play original audio
        function playOriginal() {
            if (!originalBuffer) return;

            if (originalSourceNode) {
                originalSourceNode.stop();
            }
            
            originalSourceNode = audioContext.createBufferSource();
            originalSourceNode.buffer = originalBuffer;
            originalSourceNode.connect(audioContext.destination);
            originalSourceNode.start();
            
            document.getElementById('playOriginal').textContent = '⏸️ Stop';
            originalSourceNode.onended = function() {
                document.getElementById('playOriginal').textContent = '▶️ Play Original';
            };
        }

        // Play cartoon audio
        function playCartoon() {
            if (!processedBuffer) return;

            if (cartoonSourceNode) {
                cartoonSourceNode.stop();
            }
            
            cartoonSourceNode = audioContext.createBufferSource();
            cartoonSourceNode.buffer = processedBuffer;
            cartoonSourceNode.connect(audioContext.destination);
            cartoonSourceNode.start();
            
            document.getElementById('playCartoon').textContent = '⏸️ Stop';
            cartoonSourceNode.onended = function() {
                document.getElementById('playCartoon').textContent = '▶️ Play Cartoon';
            };
        }

        // Download processed audio
        function downloadAudio() {
            if (!processedBuffer) return;

            const numberOfChannels = processedBuffer.numberOfChannels;
            const length = processedBuffer.length;
            const sampleRate = processedBuffer.sampleRate;
            const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
            const view = new DataView(arrayBuffer);

            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * numberOfChannels * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numberOfChannels * 2, true);
            view.setUint16(32, numberOfChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * numberOfChannels * 2, true);

            // Convert float samples to 16-bit PCM
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, processedBuffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            const blob = new Blob([arrayBuffer], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `advanced-cartoon-voice-${Date.now()}.wav`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Initialize
        updateAllSliderValues();
        addSliderListeners();
        setIntelligentVoicePreset('smart-cartoon');
    </script>
</body>
</html>